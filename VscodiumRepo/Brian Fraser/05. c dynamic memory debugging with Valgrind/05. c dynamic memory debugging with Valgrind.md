# Memory problems:

## **Example 1:**


``` c
void test1() {
    const int NUM_HEIGHTS = 3;
    
    int* heights = malloc(NUM_HEIGHTS);

    for (int i = 0; i < NUM_HEIGHTS; i++) {
        heights[i] = i * i;
        printf("%d: %d\n", i, heights[i]);
    }
}
```
- The previous code is very erroneous.
## First error: `invalid write of size 4`
```c
    int* heights = malloc(NUM_HEIGHTS);
```
- `malloc` allocate `sizeof` byte. In this case, it's allocate three bytes. But a single `int` needs 4 `bytes` (int my system.)
- A better way to do this is to allocate memory like this:
``` c
    int* heights = malloc(NUM_HEIGHTS * sizeof(int));
```
- This will tell malloc how much to allocate according to the type I want.
- An even better way to do it is to allocate memory like this:
``` c
    int* heights = malloc(NUM_HEIGHTS * sizeof(*heights));
```
- In this case, we don't even care about if it's `int` `double`, or `long`..., the compiler will automatically find the right `size` for us. 
- It basically go to see what the variable points to, in this case it's an `int`, so it allocate memory for `ints`

## Second error: `in use at exit: 12 bytes in 1 blocks`
- So basically it reports that we ***leaked*** 12 bytes of memory
- To solve this problem, we have to call `free()`
``` c
    free(heights)
```
- Our original code becomes:
``` c
void test1() {
    const int NUM_HEIGHTS = 3;
    
    // SOLVING THE FIRST ERROR
    int* heights = malloc(NUM_HEIGHTS * sizeof(*heights));

    for (int i = 0; i < NUM_HEIGHTS; i++) {
        heights[i] = i * i;
        printf("%d: %d\n", i, heights[i]);
    }
    // SOLVING THE SECOND ERROR
    free(heights)
}
```
## **Example 2:**
``` c
    void test2() {
        const int NUM_WEIGHTS;
        long long *weights = malloc(NUM_WEIGHTS * sizeof(weights));
        for (int i = 0; i < NUM_WEIGHTS; i++) {
            weights[i] = 100 + i;
            printf("%d: %lld\n", i, weights[i])
        }
        free(weights);
        weights[0] = 0;
    }
```

## First error: 
``` c
    long long *weights = malloc(NUM_WEIGHTS * sizeof(weights));
```
- Valgrind can't detect it because size of `long long` is 8 `bytes` which is the same as the **pointer** size on a 64bit machine.
- The solution would be:
``` c
    long long *weights = malloc(NUM_WEIGHTS * sizeof(*weights));
```
## Second error: using the memory after freeing it
``` c
    free(weights);
    weights[0] = 0;
```
- To solve this problem we should use the memory before freeing it:
``` c
    weights[0] = 0;
    free(weights);
``` 
## **Example 3:**
- Using `valgrind --leak-check=full ./bad_memory` will give more details
```c 
    void test3() {
        const int NUM_HEIGHTS = 10;
        int *heights = malloc(NUM_HEIGHTS * sizeof(*heights));
        for (int i = 0; i < NUM_HEIGHTS; i++) {
            if ((heights = NULL)) {
                heights = malloc(NUM_HEIGHTs * sizeof(*heights));
            }
        }
        free(heights);
    }
```
- The error is in the `if` statement:
- `if ((heights = NULL))`, putting extra brackets on it suppresses the error generated by the compiler.
- To solve the problem we should use double equals:
- `if(heights == Null)`
- Or it's just better to delete this code: 
``` c
    if ((heights = NULL)) {
        heights = malloc(NUM_HEIGHTs * sizeof(*heights));
    }
```

## **Example 4:**
- This test will simply print what `getString()` returns
``` c
    char* getString() {
        char message[100] = "Hello World!";
        char* ret = message;
        return ret;
    }

    void test4() {
        printf("String: %s\n", getString());
    }
```
## Error: `conditional jump or move depends on unitialised value(s)`
- Trying to use local variables initialized inside a method. It's ***evil*** to call **Stack variables** from another method, because they are popped off and they don't have the right scope. 

